/*
Уроки по CSS для НАЧИНАЮЩИХ
https://www.youtube.com/playlist?list=PL6NCtzCz-4pQZ-uueXnuIcQMs085CAhty

Как строиться css
СЕЛЕКТОР{
СВОЙСТВО:ЗНАЧЕНИЕ;
СВОЙСТВО:ЗНАЧЕНИЕ;
СВОЙСТВО:ЗНАЧЕНИЕ;
}
------------------------------------------------Селекторы и Комбинаторы------------------------------------------------
Селекторы:
    1. По типу элемента: input, span,div
    2. По классу: .class__name
    3. По идентификатору:#id_name
    4. Универсальный:*
    5. По атрибуту:
        5.1. [атрибут="A"]: состоит из A
        5.2. [атрибут$="A"]: оканчивается на A
        5.3. [атрибут*="A"]: содержит A
        5.4. [атрибут^="A"]: начинается с A
        5.5. [атрибут|="A"]: содержит A в слове с дефисом(-)
        5.6. [атрибут~="A"]: содержит A в слове с пробелом
Комбинаторы:
    1. Запятая: А, В
    2. Пробел: А В
Комбинатор потомков (пробел) - этот комбинатор выбирает все элементы, которые являются потомками определенного элемента.
    3. Дочерние: А > В
Дочерний комбинатор (>) - этот комбинатор выбирает элементы, которые являются непосредственными дочерними элементами
определенного элемента.
    4. Все соседние элементы: А ~ В
Общий соседний комбинатор (~) - этот комбинатор выбирает все элементы, которые являются соседними элементами
(находятся на одном уровне вложенности) после определенного элемента.
 CSS символ ~ используется как комбинатор соседних элементов общего родителя. Он позволяет выбирать элементы, которые
 имеют общего родителя и находятся после указанного элемента, но не обязательно непосредственно после него.
    5. Следующий соседний элемент: А + В
Смежный комбинатор (+) - этот комбинатор выбирает(один) элемент, который является непосредственным соседом (следующим)
определенного элемента.
В CSS символ + используется как комбинатор смежных соседей. Он позволяет выбирать элемент, который следует сразу за
указанным элементом и находится на одном уровне в иерархии DOM (имеет общего родителя).

---------------------------------------------Псевдоклассы и Псевдоэлементы---------------------------------------------

Псевдокласс в CSS — это ключевое слово, добавленное к селектору, которое определяет его особое состояние.
	Псевдоклассы:
		1. :active-> Когда пользователь нажимает на элемент.
		2. :hover-> Когда указатель мыши находится над элементом.
		3. :focus->При навигации с помощью клавиатуры или клике на элемент.
		4. :first-child-> Этот псевдокласс применяется к первому дочернему элементу родителя.
		5. :last-child->Этот псевдокласс применяется к последнему дочернему элементу родителя
		6. :nth-child(n/odd/even)->Этот псевдокласс применяется к элементам на основе их позиции в группе братских элементов.
		7. :nth-of-type(n)->Этот псевдокласс работает аналогично :nth-child, но учитывает только элементы определенного типа.
		7. :required->то есть обязательные для заполнения,
		    :checked->Этот псевдокласс применяется к элементам типа чекбоксов или радиокнопок, которые выбраны (отмечены),
		    :disabled-> Этот псевдокласс применяется к элементам, которые отключены (неактивны).
		8. :not()->Этот псевдокласс выбирает элементы, которые не соответствуют указанному селектору.

Псевдоэлемент в CSS — это ключевое слово, добавляемое к селектору, которое позволяет стилизовать определённую часть
выбранного элемента. Псевдоэлементобязательно должен содержать content: '' и display: inline-block;

	Псевдоэлементы:
		1. ::before
		Псевдоэлемент before вставляет текст перед элементом. Используется только совместно со свойством content,
		которое задает текст, который следует вставить. И display: inline-block; который говорит что объект должен иметь
		область видимости
		2. ::after
		3. ::placeholder

--------------------------------------------- Позиционирование(position) ---------------------------------------------

	position: static/relative/absolute/fixed;
	top, left, right, bottom
	В CSS свойства position и top, left, right, bottom используются для управления расположением элементов на веб-странице.
	1. position: static - значение по умолчанию. Элементы с position: static расположены в нормальном потоке документа.
	Свойства top, left, right, bottom для них не применяются.
	2. position: relative - элемент с position: relative располагается относительно своего обычного положения. Свойства
	top, left, right, bottom смещают элемент относительно его нормального положения.
	3. position: absolute - элемент с position: absolute позиционируется относительно ближайшего предка с position: relative,
	position: absolute или position: fixed. Если такого предка нет, то относительно начального контекста (обычно это <html>).
	4. position: fixed - элемент с position: fixed позиционируется относительно окна браузера и остается на месте даже
	при прокрутке страницы.

--------------------------------------------- background ---------------------------------------------

    0.Запись в одну строку
    background: #eee url('./cat.ico') no-repeat center center/contain;*!
    #eee->Устанавливает цвет фона элемента
    url('./cat.ico')->Устанавливает фоновое изображение, находящееся по указанному пути
    no-repeat->Указывает, что фоновое изображение не должно повторяться.
    center center->Центрирует фоновое изображение по горизонтали и вертикали внутри элемента.
    contain->Масштабирует фоновое изображение так, чтобы оно полностью поместилось внутри элемента, сохраняя свои пропорции.

	1.background
	Универсальное свойство background позволяет установить одновременно несколько характеристик фона.

	2.background-attachment: fixed, scroll
	Свойство background-attachment устанавливает, будет ли прокручиваться фоновое изображение вместе с содержимым элемента.

	3.background-image,
	Устанавливает фоновое изображение для элемента.

	4.background-origin: https://webref.ru/css/background-origin
	Свойство background-origin определяет область позиционирования фонового рисунка.

	5.background-repeat: repeat-x, repeat-y, no-repeat, space,
	Определяет, как будет повторяться фоновое изображение.

	6.background-size: cover, contain, %, px
	Масштабирует фоновое изображение, согласно заданным размерам.
	cover - масштабирует изображение с сохранением пропорций так, чтобы его ширина или высота равнялась ширине или высоте блока.
	(будет растягивать картинку пока картинка не достигнет обе границы и будет сильно увеличивать изображение)
	contain - масштабирует изображение с сохранением пропорций таким образом, чтобы картинка целиком поместилась внутрь
	блока(будет растягивать картинку пока картинка не достигнет размера какой-то границы).

	7.background-position: center center
	Задаёт начальное положение фонового изображения. Порядок не имеет значения(сначало по x потом по y),
	можно писать top,bottom, left, right, center

	8.background:linear-gradient(to top, #fefcea, #f1da36)
	Стилевая функция linear-gradient() добавляет линейный градиент к фону элемента. Она выступает значением свойства
	background-image или background.

---------------------------------------- Приоритет !important :root переменные ----------------------------------------


		Специфичность селекторов, !important, :root + переменные

Приоритет от наибольшего к наименьшему:
a - число id
b - число классов, атрибутов, псевдо-классов
c - число псевдоэлементов, тегов

:not - не участвует, но селектор внутри участвует
*, комбинаторы - не участвуют

чем длиннее тем больше приоритет :)

*               a=0 b=0 c=0 -> специфичность = 000
li              a=0 b=0 c=1 -> специфичность = 001
ul li           a=0 b=0 c=2 -> специфичность = 002
ul ol+li        a=0 b=0 c=3 -> специфичность = 003
h1 + *[href="www."]  a=0 b=1 c=1 -> специфичность = 011
ul ol li.red    a=0 b=1 c=3 -> специфичность = 013
li.red.level    a=0 b=2 c=1 -> специфичность = 021
#test           a=1 b=0 c=0 -> специфичность = 100
#test:not(p)    a=1 b=0 c=1 -> специфичность = 101
#test:not(p.test)    a=1 b=1 c=1 -> специфичность = 111


	!important — это специальная директива, используемая в CSS для повышения приоритета стиля, при которой стиль,
	помеченный !important, будет применяться, даже если существуют другие, более специфичные селекторы или стили, заданные позже в коде.

Переменные в css можно расположить в псевдоклассе: root{} и тогда переменные будут глобальные, а если их расположить в
каком-то классе то они будут локальные.
:root — это селектор, который соответствует корневому элементу документа. В HTML он эквивалентен селектору html.
    Переменные в css:
    СЕЛЕКТОР {
        --ИМЯ:ЗНАЧЕНИЕ;
        }
          СЕЛЕКТОР {
        СВОЙСТВО:var(--ИМЯ);
        }

---------------------------------------- Адаптивная верстка viewport ----------------------------------------

Чтобы строчка отображалась нормально на любых устройствах можно вставить такой костыль, который просто копируешь
вставлять из проекта в проект
    <meta name="viewport" content="width=device-width, initial-scale=1">

viewport
	Логический оператор: and or(,) not
	Тип носителя: all-для всех, screen-для различных мониторов, print-для печати, speech-для голосовых ассистентов
	Характеристики: width, height, aspect-ratio-соотношение сторон, orientation(portrait-вертик., landscape-горизонт.)-ориентация

	@media УСЛОВИЕ {
    .container{
        background: aqua;
    }}

	Пример:
	или
	@media print {
    или
	@media (max-width: 900px)
	или
	@media (aspect-ratio: 4/3)

	{.container{
        font-size: 6px;
        background: aqua;}
}

------------------------------------transition------------------------------------

В классе указывается transition а в псевдоклассе(:hover) или медиа-запросе укрываются свойства которые нужно изменить

.container {
    width: 500px;
    height: 500px;
    background: tomato;
    transition: font-size 1.5s linear .5s;
}
transition:  font-size           1.5s            linear           .5s;
            свойства=all    длительность=0s   скорость=ease   анимации=0s
              property          duration      timing-function      delay


transition можно использовать с псевдоклассами и с медиа-запросами

 Универсальное свойство, которое позволяет одновременно задать значения transition-property, transition-duration,
 transition-timing-function и transition-delay.

 Устанавливает эффект перехода между двумя состояниями элемента, они могут быть определены с помощью псевдокласса
:hover или :active, а также динамически через JavaScript.

1.Свойство transition-delay устанавливает время ожидания перед запуском эффекта перехода.

2.Свойство transition-property устанавливает имя стилевого свойства, значение которого будет отслеживаться для
создания эффекта перехода.

3.Свойство transition-duration задаёт время в секундах или миллисекундах, сколько должна длиться анимация перехода
до её завершения.

4.Свойство transition-timing-function устанавливает, насколько быстро должно изменяться значение стилевого свойство
для которого применяется эффект перехода.

.container:hover {
    background: green;
    font-size: 26px;
    color: white;
}

/*@media (max-width: 800px) {
    .container {
        background: yellow;
    }
}

------------------------------------animation------------------------------------

CSS-анимации позволяют анимировать переходы от одной конфигурации CSS стилей к другой.
animation - универсальное свойство, которое задаёт сразу несколько параметров анимации.

    animation-name: changeMargin; !*имя->может быть любое*!
    animation-duration: 5s; !*длительность->может быть любая *!
    animation-timing-function: ease; !*скорость-> ease | ease-in | ease-out | ease-in-out | linear*!
    animation-delay: 1.5s; !*задержка->может быть любая *!
    animation-fill-mode: forwards;
    !*какие стили должны применяться к элементу, когда анимация закончиться->none | forwards | backwards | both*!
    animation-iteration-count: infinite; !*кол-во повторений->может быть любое(infinite-бесконечность) *!
    animation-direction: alternate; !*направление движения анимации->normal | alternate | reverse | alternate-reverse*!

Короткая запись:
    animation:5s ease 1.5s forwards infinite alternate changeMargin

Порядок:
 animation:1s ease .5s infinite alternate move

animation: duration|timing-function|
delay|iteration-count|
direction|fill-mode|name

Правило @keyframes устанавливает ключевые кадры при анимации элемента. Ключевой кадр это свойства элемента (прозрачность,
цвет, положение и др.), которые должны применяться к элементу в заданный момент времени. Таким образом, анимация
представляет собой плавный переход стилевых свойств от одного ключевого кадра к другому. Вычисление промежуточных
значений между такими кадрами берёт на себя браузер.
Анимация может использовать ключевые слова from и to, а так же проценты 0% 20% 50% 100%

@keyframes move {
    from{
    margin-top:0;
    }
    to{
        margin-left: 500px;
    }
}

------------------------------------transform------------------------------------

Трансформирует элемент, в частности, позволяет его масштабировать, вращать, сдвигать, наклонять, а также комбинировать
виды трансформаций, перечисляя функции трансформации через пробел.

transform-origin-Устанавливает координаты точки, относительно которой будет происходить трансформация элемента.


Функции трансформации:

rotate()-Поворачивает элемент в двумерном пространстве на заданный угол относительно точки трансформации, задаваемой
свойством transform-origin.

scale()-Масштабирует элемент по горизонтали и вертикали.

translate()-Сдвигает элемент на заданное значение по горизонтали и вертикали.

translateX()-Сдвигает элемент по горизонтали на указанное значение. Положительное значение сдвигает вправо, отрицательное влево.

translateY()-Сдвигает элемент по вертикали на указанное значение. Положительное значение сдвигает вниз, отрицательное вверх.

translateZ()-Сдвигает элемент по оси Z на указанное значение. Положительное значение сдвигает вперёд, отрицательное назад.

Первоначально нужно задать начальные значения для transform и transform-origin(если нужно вращать) в классе и задать
animation с именем и параметрами, а потом задать @keyframes с именем и конечными значениями transform

Пример
.circle {
    transform: rotate(0deg);
    transform-origin: top left;
    animation:5s ease .5s forwards infinite alternate translateX;
}

@keyframes translateX {
    50% {
        transform: rotate(360deg) translate(100px) scale(2);
    }
    100%{
        transform: rotate(720deg) translate(0px) scale(1);
    }
}

------------------------------------box-sizing------------------------------------

box-sizing - Применяется для изменения алгоритма расчёта ширины и высоты элемента.

Согласно спецификации CSS ширина блока складывается из ширины содержимого (width), значений margin, padding и border.
Свойство box-sizing позволяет изменить этот алгоритм, чтобы свойства width и height задавали размеры не содержимого, а
размеры блока.

content-box
Основывается на стандартах CSS, при этом свойства width и height задают ширину и высоту содержимого и не включают в себя
значения margin, padding и border.

border-box
Свойства width и height включают в себя значения padding и border, но не margin.
Синтаксис
box-sizing: content-box | border-box
Рекомендую делать такую запись в начале каждого css документа
*{
    box-sizing: border-box;
}

------------------------------------Префиксы------------------------------------

Префиксы нужны для кроссбраузерности, то есть чтобы отображалась нормально на разных браузерах.
Префиксы обычно в ручную не пишутся.
Кросбраузерность это когда сайт выглядит одинаково в разных браузерах

autoprefixer: http://autoprefixer.github.io/ru/

------------------------------------normalize------------------------------------

normalize исходники: https://clck.ru/VRmgD
Этот файл будет как осново для начало работы, чтобы все браузеры отображали сайт одинаково и сбрасывает не нужные стили


------------------------------------normalize & reset------------------------------------
Ссылки на сайт которые сбрасывают настройки до normalize или reset

normalize.css: https://cdnjs.com/libraries/normalize
reset.css: https://cdnjs.com/libraries/meyer-reset

Они подключаются через html-> link
    <link
            rel="stylesheet"
            type="text/css"
            href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css"
    />

 */



*{
    box-sizing: border-box;
}
/*Селектор по типу элемента*/
body {
    /*font-size: 46px;*/
    margin: 0;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
}


/*.block{
    width: 300px;
    height: 300px;
    background: tomato;
    border: 5px solid black;
    padding: 15px;
}*/

.container{
    width: 300px;
    height: 500px;
    background: darkgrey;
    margin: 0;
    padding: 0;
}

.child1,.child2{
    display: inline-block;
    width: 148px;
    height: 30px;
    background: tomato;
    padding: 5px;
    margin: 0;
    border: 2px solid red;
}

.child2{
    background: blue;
}










