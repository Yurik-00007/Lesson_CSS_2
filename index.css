/*
Уроки по CSS для НАЧИНАЮЩИХ
https://www.youtube.com/watch?v=oEOhLPEbDPw

Как строиться css
СЕЛЕКТОР{
СВОЙСТВО:ЗНАЧЕНИЕ;
СВОЙСТВО:ЗНАЧЕНИЕ;
СВОЙСТВО:ЗНАЧЕНИЕ;
}
------------------------------------------------Селекторы и Комбинаторы------------------------------------------------
Селекторы:
    1. По типу элемента: input, span,div
    2. По классу: .class__name
    3. По идентификатору:#id_name
    4. Универсальный:*
    5. По атрибуту:
        5.1. [атрибут="A"]: состоит из A
        5.2. [атрибут$="A"]: оканчивается на A
        5.3. [атрибут*="A"]: содержит A
        5.4. [атрибут^="A"]: начинается с A
        5.5. [атрибут|="A"]: содержит A в слове с дефисом(-)
        5.6. [атрибут~="A"]: содержит A в слове с пробелом
Комбинаторы:
    1. Запятая: А, В
    2. Пробел: А В
Комбинатор потомков (пробел) - этот комбинатор выбирает все элементы, которые являются потомками определенного элемента.
    3. Дочерние: А > В
Дочерний комбинатор (>) - этот комбинатор выбирает элементы, которые являются непосредственными дочерними элементами
определенного элемента.
    4. Все соседние элементы: А ~ В
Общий соседний комбинатор (~) - этот комбинатор выбирает все элементы, которые являются соседними элементами
(находятся на одном уровне вложенности) после определенного элемента.
 CSS символ ~ используется как комбинатор соседних элементов общего родителя. Он позволяет выбирать элементы, которые
 имеют общего родителя и находятся после указанного элемента, но не обязательно непосредственно после него.
    5. Следующий соседний элемент: А + В
Смежный комбинатор (+) - этот комбинатор выбирает(один) элемент, который является непосредственным соседом (следующим)
определенного элемента.
В CSS символ + используется как комбинатор смежных соседей. Он позволяет выбирать элемент, который следует сразу за
указанным элементом и находится на одном уровне в иерархии DOM (имеет общего родителя).

---------------------------------------------Специфичность css---------------------------------------------
html
<div id="index" class="test" style="background: #000; width: 100px;height: 100px;"></div>

css
Читать css снизу вверх(приоритет идет от меньшего к большему).
---------------------------------------------------------------
Правило !importantв CSS используется для придания свойству/значению большей важности, чем обычно(❗Наивысший приоритет).
Фактически, если вы используете это !important правило, оно переопределит ВСЕ предыдущие правила стилизации для этого
конкретного свойства этого элемента! Правило !importantв CSS можно применить к абсолютно любому селектору.
.test{ background: #ccc !important; }

Если написать инлаин стили, то будет 1000 баллов. Он имеет наивысший приоритет. Пишутся инлаин стили в теге который находиться в html.
// 1.0.0.0
<div id="index" class="test" style="background: #000; width: 100px;height: 100px;"></div>
// 0.1.0.0
Если написать обращение по идентификатору, то будет 100 баллов.
❗Но идентификатор можно использовать только один на странице и он должен быть уникальным.
//0.1.0.0
#index { background: #ccc; }
если написать обращение по классу к тегу то соответственно
будет 11 баллов.
//0.0.1.1
.body div{ background: #ccc; }
если написать обращение по классу к классу то соответственно
будет 20 баллов.
//0.0.2.0
.body .test{ background: #ccc; }
Это все мишура обращение по классу дает 10 баллов.
//0.0.1.0
.test{ background: #ccc; }
Это обращение по тегу к вложенному тегу дает 1 балл плюс 1 балл равно 2 бала. Если будет тройная вложенность то будет 3
балла.
//0.0.0.2
body div{ background-color: red; }
Это обращение по тегу дает 1 балл.
//0.0.0.1
div{ background-color: blue; }

---------------------------------------------------------------
В классах то свойство которое ниже будет иметь больший приоритет чем которое выше. Это есть специфичность. Она не такая
простая. За это все есть баллы.

0.0.1.0
.test{
    width: 200px;
    height: 200px; background-color:
background: #ccc;
}
Праритет выше так как ниже
.test{
    background: #000;
}

---------------------------------------------Псевдоклассы и Псевдоэлементы---------------------------------------------

Псевдокласс в CSS — это ключевое слово, добавленное к селектору, которое определяет его особое состояние.
	Псевдоклассы:
		1. :active-> Когда пользователь нажимает на элемент.
		2. :hover-> Когда указатель мыши находится над элементом.
		3. :focus->При навигации с помощью клавиатуры или клике на элемент.
		4. :first-child-> Этот псевдокласс применяется к первому дочернему элементу родителя.
		5. :last-child->Этот псевдокласс применяется к последнему дочернему элементу родителя
		6. :nth-child(n/odd/even)->Этот псевдокласс применяется к элементам на основе их позиции в группе братских элементов.
		7. :nth-of-type(n)->Этот псевдокласс работает аналогично :nth-child, но учитывает только элементы определенного типа.
		8. :required->то есть обязательные для заполнения,
		9. :checked->Этот псевдокласс применяется к элементам типа чекбоксов или радиокнопок, которые выбраны (отмечены),
		10.:disabled-> Этот псевдокласс применяется к элементам, которые отключены (неактивны).
		11.:not()->Этот псевдокласс выбирает элементы, которые не соответствуют указанному селектору.

Псевдоэлемент в CSS — это ключевое слово, добавляемое к селектору, которое позволяет стилизовать определённую часть
выбранного элемента. Псевдоэлементобязательно должен содержать content: '' и display: inline-block;

	Псевдоэлементы:
		1. ::before
		Псевдоэлемент before вставляет текст перед элементом. Используется только совместно со свойством content,
		которое задает текст, который следует вставить. И display: inline-block; который говорит что объект должен иметь
		область видимости
		2. ::after
		3. ::placeholder

--------------------------------------------- Позиционирование(position) ---------------------------------------------

	position: static/relative/absolute/fixed;
	top, left, right, bottom
	В CSS свойства position и top, left, right, bottom используются для управления расположением элементов на веб-странице.
	1. position: static - значение по умолчанию. Элементы с position: static расположены в нормальном потоке документа.
	Свойства top, left, right, bottom для них не применяются.
	2. position: relative - элемент с position: relative располагается относительно своего обычного положения. Свойства
	top, left, right, bottom смещают элемент относительно его нормального положения.
	3. position: absolute - элемент с position: absolute позиционируется относительно ближайшего предка с position: relative,
	position: absolute или position: fixed. Если такого предка нет, то относительно начального контекста (обычно это <html>).
	4. position: fixed - элемент с position: fixed позиционируется относительно окна браузера и остается на месте даже
	при прокрутке страницы.
	5. position: sticky - элемент с position: sticky в CSS используется для создания "липкого" позиционирования элементов,
	при котором элемент ведет себя как relative до тех пор, пока не достигает заданного порога (обычно верхнего или нижнего
	 края родительского элемента или окна браузера), после чего он ведет себя как fixed.

--------------------------------------------- background ---------------------------------------------

    0.Запись в одну строку
    background: #eee url('./cat.ico') no-repeat center center/contain;
    #eee->Устанавливает цвет фона элемента
    url('./cat.ico')->Устанавливает фоновое изображение, находящееся по указанному пути
    no-repeat->Указывает, что фоновое изображение не должно повторяться.
    center center->Центрирует фоновое изображение по горизонтали и вертикали внутри элемента.
    contain->Масштабирует фоновое изображение так, чтобы оно полностью поместилось внутри элемента, сохраняя свои пропорции.

	1.background
	Универсальное свойство background позволяет установить одновременно несколько характеристик фона.

	2.background-attachment: fixed, scroll
	Свойство background-attachment устанавливает, будет ли прокручиваться фоновое изображение вместе с содержимым элемента.

	3.background-image,
	Устанавливает фоновое изображение для элемента.

	4.background-origin: https://webref.ru/css/background-origin
	Свойство background-origin определяет область позиционирования фонового рисунка.

	5.background-repeat: repeat-x, repeat-y, no-repeat, space,
	Определяет, как будет повторяться фоновое изображение.

	6.background-size: cover, contain, %, px
	Масштабирует фоновое изображение, согласно заданным размерам.
	cover - масштабирует изображение с сохранением пропорций так, чтобы его ширина или высота равнялась ширине или высоте блока.
	(будет растягивать картинку пока картинка не достигнет обе границы и будет сильно увеличивать изображение)
	contain - масштабирует изображение с сохранением пропорций таким образом, чтобы картинка целиком поместилась внутрь
	блока(будет растягивать картинку пока картинка не достигнет размера какой-то границы).

	7.background-position: center center
	Задаёт начальное положение фонового изображения. Порядок не имеет значения(сначало по x потом по y),
	можно писать top,bottom, left, right, center

	8.background:linear-gradient(to top, #fefcea, #f1da36)
	Стилевая функция linear-gradient() добавляет линейный градиент к фону элемента. Она выступает значением свойства
	background-image или background.

---------------------------------------- Приоритет !important :root переменные ----------------------------------------


		Специфичность селекторов, !important, :root + переменные

Приоритет от наибольшего к наименьшему:
a - число id
b - число классов, атрибутов, псевдо-классов
c - число псевдоэлементов, тегов

:not - не участвует, но селектор внутри участвует
*, комбинаторы - не участвуют

чем длиннее тем больше приоритет :)

*               a=0 b=0 c=0 -> специфичность = 000
li              a=0 b=0 c=1 -> специфичность = 001
ul li           a=0 b=0 c=2 -> специфичность = 002
ul ol+li        a=0 b=0 c=3 -> специфичность = 003
h1 + *[href="www."]  a=0 b=1 c=1 -> специфичность = 011
ul ol li.red    a=0 b=1 c=3 -> специфичность = 013
li.red.level    a=0 b=2 c=1 -> специфичность = 021
#test           a=1 b=0 c=0 -> специфичность = 100
#test:not(p)    a=1 b=0 c=1 -> специфичность = 101
#test:not(p.test)    a=1 b=1 c=1 -> специфичность = 111


	!important — это специальная директива, используемая в CSS для повышения приоритета стиля, при которой стиль,
	помеченный !important, будет применяться, даже если существуют другие, более специфичные селекторы или стили, заданные позже в коде.

Переменные в css можно расположить в псевдоклассе: root{} и тогда переменные будут глобальные, а если их расположить в
каком-то классе то они будут локальные.
:root — это селектор, который соответствует корневому элементу документа. В HTML он эквивалентен селектору html.
    Переменные в css:
    СЕЛЕКТОР {
        --ИМЯ:ЗНАЧЕНИЕ;
        }
          СЕЛЕКТОР {
        СВОЙСТВО:var(--ИМЯ);
        }

---------------------------------------- Адаптивная верстка viewport ----------------------------------------

Чтобы строчка отображалась нормально на любых устройствах можно вставить такой костыль, который просто копируешь
вставлять из проекта в проект
    <meta name="viewport" content="width=device-width, initial-scale=1">

viewport
	Логический оператор: and or(,) not
	Тип носителя: all-для всех, screen-для различных мониторов, print-для печати, speech-для голосовых ассистентов
	Характеристики: width, height, aspect-ratio-соотношение сторон, orientation(portrait-вертик., landscape-горизонт.)-ориентация

	@media УСЛОВИЕ {
    .container{
        background: aqua;
    }}

	Пример:
	или
	@media print {
    или
	@media (max-width: 900px)
	или
	@media (aspect-ratio: 4/3)

	{.container{
        font-size: 6px;
        background: aqua;}
}

------------------------------------transition------------------------------------

В классе указывается transition а в псевдоклассе(:hover) или медиа-запросе укрываются свойства которые нужно изменить

.container {
    width: 500px;
    height: 500px;
    background: tomato;
    transition: font-size 1.5s linear .5s;
}
transition:  font-size           1.5s            linear           .5s;
            свойства=all    длительность=0s   скорость=ease   анимации=0s
              property          duration      timing-function      delay


transition можно использовать с псевдоклассами и с медиа-запросами

 Универсальное свойство, которое позволяет одновременно задать значения transition-property, transition-duration,
 transition-timing-function и transition-delay.

 Устанавливает эффект перехода между двумя состояниями элемента, они могут быть определены с помощью псевдокласса
:hover или :active, а также динамически через JavaScript.

1.Свойство transition-delay устанавливает время ожидания перед запуском эффекта перехода.

2.Свойство transition-property устанавливает имя стилевого свойства, значение которого будет отслеживаться для
создания эффекта перехода.

3.Свойство transition-duration задаёт время в секундах или миллисекундах, сколько должна длиться анимация перехода
до её завершения.

4.Свойство transition-timing-function устанавливает, насколько быстро должно изменяться значение стилевого свойство
для которого применяется эффект перехода.

.container:hover {
    background: green;
    font-size: 26px;
    color: white;
}

@media (max-width: 800px) {
    .container {
        background: yellow;
    }
}

------------------------------------animation------------------------------------

CSS-анимации позволяют анимировать переходы от одной конфигурации CSS стилей к другой.
animation - универсальное свойство, которое задаёт сразу несколько параметров анимации.

    animation-name: changeMargin;-->имя->может быть любое
    animation-duration: 5s;-->длительность->может быть любая
    animation-timing-function: ease;-->скорость-> ease | ease-in | ease-out | ease-in-out | linear
    animation-delay: 1.5s;-->задержка->может быть любая
    animation-fill-mode: forwards;
   -->какие стили должны применяться к элементу, когда анимация закончиться->none | forwards | backwards | both
    animation-iteration-count: infinite;-->кол-во повторений->может быть любое(infinite-бесконечность)
    animation-direction: alternate;-->направление движения анимации->normal | alternate | reverse | alternate-reverse

Короткая запись:
    animation:5s ease 1.5s forwards infinite alternate changeMargin

Порядок:
 animation:1s ease .5s infinite alternate move

animation: duration|timing-function|
delay|iteration-count|
direction|fill-mode|name

Правило @keyframes устанавливает ключевые кадры при анимации элемента. Ключевой кадр это свойства элемента (прозрачность,
цвет, положение и др.), которые должны применяться к элементу в заданный момент времени. Таким образом, анимация
представляет собой плавный переход стилевых свойств от одного ключевого кадра к другому. Вычисление промежуточных
значений между такими кадрами берёт на себя браузер.
Анимация может использовать ключевые слова from и to, а так же проценты 0% 20% 50% 100%

@keyframes move {
    from{
    margin-top:0;
    }
    to{
        margin-left: 500px;
    }
}

------------------------------------transform------------------------------------

Трансформирует элемент, в частности, позволяет его масштабировать, вращать, сдвигать, наклонять, а также комбинировать
виды трансформаций, перечисляя функции трансформации через пробел.

transform-origin-Устанавливает координаты точки, относительно которой будет происходить трансформация элемента.


Функции трансформации:

rotate()-Поворачивает элемент в двумерном пространстве на заданный угол относительно точки трансформации, задаваемой
свойством transform-origin.

scale()-Масштабирует элемент по горизонтали и вертикали.

translate()-Сдвигает элемент на заданное значение по горизонтали и вертикали.

translateX()-Сдвигает элемент по горизонтали на указанное значение. Положительное значение сдвигает вправо, отрицательное влево.

translateY()-Сдвигает элемент по вертикали на указанное значение. Положительное значение сдвигает вниз, отрицательное вверх.

translateZ()-Сдвигает элемент по оси Z на указанное значение. Положительное значение сдвигает вперёд, отрицательное назад.

Первоначально нужно задать начальные значения для transform и transform-origin(если нужно вращать) в классе и задать
animation с именем и параметрами, а потом задать @keyframes с именем и конечными значениями transform

Пример
.circle {
    transform: rotate(0deg);
    transform-origin: top left;
    animation:5s ease .5s forwards infinite alternate translateX;
}

@keyframes translateX {
    50% {
        transform: rotate(360deg) translate(100px) scale(2);
    }
    100%{
        transform: rotate(720deg) translate(0px) scale(1);
    }
}

------------------------------------box-sizing------------------------------------

box-sizing - Применяется для изменения алгоритма расчёта ширины и высоты элемента.

Согласно спецификации CSS ширина блока складывается из ширины содержимого (width), значений margin, padding и border.
Свойство box-sizing позволяет изменить этот алгоритм, чтобы свойства width и height задавали размеры не содержимого, а
размеры блока.

content-box
Основывается на стандартах CSS, при этом свойства width и height задают ширину и высоту содержимого и не включают в себя
значения margin, padding и border.

border-box
Свойства width и height включают в себя значения padding и border, но не margin.
Синтаксис
box-sizing: content-box | border-box
Рекомендую делать такую запись в начале каждого css документа
*{
    box-sizing: border-box;
}

------------------------------------Префиксы------------------------------------

Префиксы нужны для кроссбраузерности, то есть чтобы отображалась нормально на разных браузерах.
Префиксы обычно в ручную не пишутся.
Кросбраузерность это когда сайт выглядит одинаково в разных браузерах

autoprefixer: http://autoprefixer.github.io/ru/

------------------------------------normalize------------------------------------

normalize исходники: https://clck.ru/VRmgD
Этот файл будет как осново для начало работы, чтобы все браузеры отображали сайт одинаково и сбрасывает не нужные стили


------------------------------------normalize & reset------------------------------------
Ссылки на сайт которые сбрасывают настройки до normalize или reset

normalize.css: https://cdnjs.com/libraries/normalize
reset.css: https://cdnjs.com/libraries/meyer-reset

Они подключаются через html-> link
    <link
            rel="stylesheet"
            type="text/css"
            href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css"
    />


------------------------------------Не супер важные свойства------------------------------------
1.line-height - свойство line-height устанавливает интервал между строками текста (межстрочный интервал).
2.list-style-type - свойство list-style-type позволяет для списка ul вместо маркеров-точек сделать квадраты или окружности.
Для списка ol вместо обычных цифр можно сделать римские, нумерацию в виде букв: латинских или греческих. Часто используется
с none чтобы убрать значения по умолчанию для списка.
3.text-decoration - cвойство text-decoration добавляет тексту различные эффекты: подчеркивание, перечеркивание, линию сверху.
Часто используется чтобы отменить подчеркивания ссылки.
4.box-shadow - Свойство box-shadow задает тень блоку. В качестве значения свойство принимает 6 параметров, перечисляемые
через пробел, либо ключевое слово none, отменяющее тень совсем.
https://active-vision.ru/icon/box-shadow/
5.object-fit - управляет соотношением сторон заменяемых элементов, таких как <img> и <video>, когда у них задана ширина
или высота, а также способом масштабирования. свойство похоже на background-size
object-fit: fill | contain | cover | none
    fill - элемент масштабируется, чтобы соответствовать заданным размерам, при этом пропорции игнорируются.
	cover - масштабирует изображение с сохранением пропорций так, чтобы его ширина или высота равнялась ширине или высоте блока.
	(будет растягивать картинку пока картинка не достигнет обе границы и будет сильно увеличивать изображение)
	contain - масштабирует изображение с сохранением пропорций таким образом, чтобы картинка целиком поместилась внутрь
	блока(будет растягивать картинку пока картинка не достигнет размера какой-то границы).
	none - сохраняются исходные пропорции элемента, установленные значения ширины или высоты не влияют на содержимое.
6. object-position - cвойство object-position применяется для выравнивания содержимого такого элемента как <img>, <video> или <object>
внутри его блока. Это свойство работает аналогично background-position для фоновых изображений.
7.inherit - ключевое слово, которое сообщает, что необходимо наследовать значение свойства у родительского элемента. Естественно,
результат будет заметен только в том случае, если у родителя указанное свойство установлено.
8.min-width - устанавливает максимальную ширину элемента.
9.max-width - устанавливает минимальную ширину элемента.
10. filter - Свойство filter задает фоновому изображению определенный художественный стиль или фильтр. Свойство может
принимать в качестве значений названия художественных стилей, формируемых функцией filter или none (отмена выбранного
фильтра).
filter:blur()->размытие, brightness()->яркость, contrast()->контрастность, grayscale()->чернобелость, saturate()->насыщенность,
sepia()->старина, invert()->инвертация, opacity()->прозрачности.

----------------------------------------------------------flex----------------------------------------------------------
display:flex ->размечает контейнер для его элементов

Свойства которые применяются непосредственно к flex-контейнеру⬇️:

flex-direction-->Свойство устанавливает направление главной и поперечной оси или, говоря другими словами, расставляет
элементы в ряд или в колонку.
Синтаксис
селектор {
	flex-direction: row | row-reverse | column | column-reverse;}

row-->Главная ось направлена слева направо. Элементы расположены в ряд, по умолчанию прижаты к левому краю, их нумерация имеет
обычный порядок - слева направо.
row-reverse-->Главная ось направлена справа налево. Элементы расположены в ряд, по умолчанию прижаты к правому краю, их
нумерация имеет обратный порядок - справа налево.
column-->Главная ось направлена сверху вниз. Элементы расположены в колонку, по умолчанию прижаты к верху, их нумерация
имеет обычный порядок - сверху вниз.
column-reverse-->Главная ось направлена снизу вверх. Элементы расположены в колонку, по умолчанию прижаты к низу, их
нумерация имеет обратный порядок - снизу вверх.

justify-content->Определяет, как браузер распределяет пространство вокруг флекс-элементов вдоль главной оси контейнера.
Синтаксис
селектор {
justify-content: flex-start | flex-end | center | space-between |
                 space-around | space-evenly}

flex-start->Флексы прижаты к началу строки.
flex-end -> Флексы прижаты к концу строки.
center -> Флексы выравниваются по центру строки.
space-between -> Флексы равномерно распределяются по всей строке. Первый и последний элемент прижимаются к соответствующим краям контейнера.
space-around -> Флексы равномерно распределяются по всей строке. Пустое пространство перед первым и после последнего элементов равно половине пространства между двумя соседними элементами.
space-evenly -> Флексы распределяются так, что расстояние между любыми двумя соседними элементами, а также перед первым и после последнего, было одинаковым.

Свойство align-items выравнивает флекс-элементы внутри контейнера вдоль второстепенной оси направлении.
Синтаксис
селектор {
align-items: flex-start | flex-end | center | baseline | stretch}

stretch->Флексы растягиваются таким образом, чтобы занять всё доступное пространство контейнера.
baseline->Флексы выравниваются по их базовой линии(верхняя строка низ у всех flex-элементов).

flex-wrap - cвойство задает многострочную расстановку блоков по главной оси. Применяется к родительскому элементу для flex
блоков. Входит в свойство-сокращение flex-flow.
Синтаксис
селектор {
flex-wrap: nowrap | wrap | wrap-reverse;}

nowrap-->Однострочный режим - блоки выстраиваются в одну строку.
wrap-->Блоки выстраиваются в несколько строк, если не помещаются в одну.
wrap-->reverse	То же самое, что и wrap, но блоки выстраиваются в другом порядке (сначала последний, потом первый).


align-content - свойство задает выравнивание элементов вдоль поперечной оси для flex блоков и по горизонтальной оси для
гридов. Применяется к родительскому элементу. Если у нас более одной строки с элементомами то это свойство можно применять.
Оно выравнит строки с элементами в кантейнере.
Синтаксис
селектор {
align-content: flex-start | flex-end | center | space-between | space-around;}

flex-start-->Блоки прижаты к началу поперечной (вертикальной) оси.
flex-end-->Блоки прижаты к концу поперечной (вертикальной) оси.
center-->Блоки стоят по центру поперечной (вертикальной) оси.
space-between-->Блоки распределены вдоль поперечной (вертикальной) оси, при этом первый элемент прижат к началу оси, а последний - к концу.
space-around-->Блоки распределены вдоль поперечной (вертикальной) оси, при этом между первым блоком и началом оси, последним блоком и концом оси такой же промежуток, как и между остальными блоками.
Однако, они не равны, как могло бы показаться: промежутки суммируются и между двумя блоками расстояние в два раза больше, чем между блоком и началом/концом оси.

Свойства которые применяются непосредственно к flex-элементу⬇️:

align-self - Свойство align-self задает выравнивание вдоль поперечной оси для отдельно взятого flex-блока и по
вертикальной оси для отдельного элемента в флекс. По сути данное свойство представляет собой свойство align-items,
но для конкретного блока.
Синтаксис
селектор {
align-self: auto | flex-start | flex-end | center | baseline | stretch;}

flex-start-->Блоки прижаты к началу поперечной (вертикальной) оси.
flex-end-->Блоки прижаты к концу поперечной (вертикальной) оси.
center-->Блоки стоят по центру поперечной (вертикальной) оси.
space-between-->Блок выравнивается по своей базовой линии. Базовая линия (англ. baseline, или линия шрифта) - это
воображаемая линия, проходящая по нижнему краю символов без учета свисаний, например, как у букв 'ц', 'д', 'р', 'щ'.
stretch-->Блок растянут, занимая все доступное место по поперечной оси, при этом все же учитываются min-width и max-width,
если они заданы. Если же задана ширина и высота для элемента - stretch будет проигнорирован.
auto-->Блок будет выровнен так, как задано в свойстве align-items.

order - cвойство задает порядок следования отдельно взятого flex-блока(элемента) внутри flex-контейнера.
Применяется к конкретному flex блоку. Своим значением свойство принимает положительное или отрицательное целое число.
Чем меньше число - тем раньше будет стоять элемент, независимо от расположения в HTML коде относительно других элементов.

margin:0 auto;
Это свойство позволяет центрировать элемент отнасительно контейнера. можно сравнить с justify-content:center;
Только justify-content -это для flex-контейнера, margin:0 auto;-для flex-элемента

свойства которые применяются на родителя: display:flex,justify-content,align-items,align-content
свойства которые применяются на детей: align-self, order,flex-basis, flex-shrink,

================flex-basis, flex-grow, flex-shrink. flexbox погружение======================
https://www.youtube.com/watch?v=QuAVrIRjkjE

flex-grow(по ширине) - свойство определяет каэфициент растяжения свободного прастранства того, на сколько отдельный
flex-блок может быть больше соседних элементов, если это необходимо.
flex-grow:0->по умолчанию

https://code.mu/ru/markup/manual/css/property/flex-grow/

1.Если у элементов не задан размкер а задан только flex-grow, они распределяться равномерно отнасилельно значению контейнера(width:900)
и элементов первого(flex-grow: 1;) и второго(flex-grow: 2;). В этом случае ширина обшего контейнера(900) поделиться
на 3 части и каждому достанеться по соответствующему значению: первому(1*300=300) и второму(2*300=600)

2.Если суммарная ширина элементов меньше ширины родителя, поэтому справа остается пустое пространство. При желании это
пустое пространство можно пропорционально разделить между нашими элементами. Это делается с помощью свойства flex-grow,
задаваемого флекс-элементам. Как это будет выглядить. Размер ширины контейнера 1000px, а размер первого и второго
flex-элемента по 200px, значит у нас образуеться пустое пространство равное 500px, его можно поделить при использование
к каждому элементу  flex-grow: к первому flex-grow: 1;ко второму flex-grow: 2;. И тогда свободное пространство делиться
на 3 части и добовляеться к каждому элементу:600/3=200 первый-->200(его размер)+(200*1)=400 и
второй 200(его размер)+(200*2)=600

3.Если контент забрал все свободное место то писать flex-grow бесполезно так как он не будет работать

flex-shrink - cвойство определяет коэфициент сжатия того, насколько flex-блок(элемент) будет уменьшаться относительно
соседних элементов внутри flex-контейнера в случае недостатка свободного места.
flex-shrink:1->по умолчанию
flex-shrink:0-->flex-блок(элемент) не будет изменять размер присжатие экрана
https://code.mu/ru/markup/manual/css/property/flex-shrink/

flex-basis - свойство задает размер элемента вдоль главной оси. Это значит, что если главная ось горизонтальна - это
свойство будет задавать ширину элементов, а если вертикальна - то высоту.
flex-basis имеет приоритет над width но приоритет у него ниже чем у min-width и max-width
https://code.mu/ru/markup/manual/css/property/flex-basis/

shortcut(сокращение)
Свойство flex сокращение для flex-grow, flex-shrink и flex-basis.
https://developer.mozilla.org/ru/docs/Web/CSS/flex#%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%81

Пример:
flex:0 1 auto;-->по умолчанию
можно расписать так
flex-grow:0;
flex-shrink:1;
flex-basis:auto;

 0 0 auto
flex: none;

 Одно значение, число без единиц: flex-grow->всегда первое, если нет единиц
flex: 2;

----------------------------------------------------------grid----------------------------------------------------------

Чтобы четко видеть grid-линии нужно в панели разработчика нажать grit-контейнер->grit и так же можно задать цвет
разметки, если выбрать во втором подокне Layout

Свойства которые применяются непосредственно к grid-контейнеру⬇️:

display: grid
Grid представляет собой пересекающийся набор горизонтальных и вертикальных линий, образующих колонки и строки.
Элементы могут быть помещены в grid в пределах линий этих колонок и строк.

display: grid — это CSS-свойство, которое преобразует элемент в контейнер сетки (grid container).
Внутри этого контейнера его дочерние элементы (grid items) располагаются в виде сетки, что позволяет легко управлять
их расположением и размером.

grid-template-columns - свойство grid-template-columns задает количество и ширину столбцов, которые будет занимать
элемент в гриде или сетке.
Единицы измерения:
 -> пикселях размеры столбцов будут точно им соответствовать.
 ->auto, то столбцы будут заполнять размер равный контенту.
 ->fr (фракция) означает, что все пространство будет разбито на одинаковые доли(преимущество адаптивность).
 пример:
  grid-template-columns: 200px 200px 200px;
  или короткая запись
   grid-template-columns: repeat(3, 200px);->кол-во колонок, размер

 grid-template-rows - свойство grid-template-rows задает количество и ширину рядов, которые будет занимать элемент в
 гриде или сетке.

grid-auto-rows,grid-auto-columns - свойство grid-auto-columns,rows задает ширину столбцов(строк), которые
будет занимать элемент в неявном гриде.Т.е. можно задать размер для одной строки( grid-template-rows: 200px), а потом с
 помощью grid-auto-rows задать свойство, которое будет применяться для остальных строк().
 Пример:
 grid-auto-rows: 125px 225px;
   для того чтобы задать не явным ячейкам нужный размер можно применить grid-auto-rows,
     т.е. не важно сколько их еще будет высота все равно будет 125px
     Если написать более одного значения то высота будет повторяться: первый ряд будет 125px, а второй будет 225px


 minmax() это CSS функция, определяющая диапазон размеров, который больше или равен min или растянется до max.
 Аналогично min-width и max-width, но только для grit-self.
 пример:
 grid-template-columns: repeat(3,minmax(100px,200px));


SHORTCUTS-КОРОТКАЯ ЗАПИСЬ
 gap - свойство gap задает расстояние между элементами в гриде. В значении свойства в элементе-родителе указываем нужное
 нам расстояние с единицами измерения - px, % и т.п.
 или есть альтернативные свойства grid-column-gap и grid-row-gap

 justify-items - свойство justify-items задает выравнивание элементов внутри ячеек grid по горизонтальной оси.Применяется
 к родительскому элементу.
 align-items - свойство align-items задает выравнивание элементов вдоль по вертикальной оси для grid и поперечной оси
 для flex блоков. Применяется к родительскому элементу.
 SHORTCUTS-КОРОТКАЯ ЗАПИСЬ
place-items: end start;
place-items: stretch;

auto - столбцы с auto подстраиваются под контент, занимая минимально необходимое пространство. Это не значит что 2 auto
будут равны(auto не значит равная часть) размер в auto высчитывается относительно заполняемого объема ячейки
пример: grid-template-columns: 1fr auto auto;
1fr -равная часть, выберут самую большую ячейку и от размера её сделают для каждой ячейки такой размер.

SHORTCUTS-КОРОТКАЯ ЗАПИСЬ
свойства можно объединять вот некоторые, которые часто применяються из них:
grid-template: стрки/столбцы
grid-template: 300px 300px 300px/ 1fr 1fr 1fr;
grid-template:repeat(3, 300px)/ repeat(3, 1fr);

grid-auto-flow-Свойство задает автоматическое размещение элементов в гриде. Может иметь значения row -
заполняет ряды элементами(вниз), column - столбцы(вправо) dense - размещает элементы на все пустые места в сетке; row dense -
располагает элементы, заполняя каждый ряд и все свободные места сетки; column dense - заполняет элементами каждый
столбец и все свободное место в гриде.

Grid-линиям можно задать имена в квадратных скобка
grid-template-columns:[col1] 400px [col-item2] 400px [sth3] 400px [four];
grid-template-rows:[row1] 100px [row-item2] 300px [ath3] 150px [five];

grid-template-areas - Свойство grid-template-areas задает размещение элементов в гриде. Вначале каждому элементу-потомку
задаем имя с помощью свойства grid-area. Затем в элементе-родителе мы указываем свойство grid-template-areas, в котором
перечисляем имена элементов-потомков в том порядке, в каком хотим их разместить в гриде.
Пример:
    grid-template-areas:
            'a a b'
            'a a b'
            'c c b';

Свойства которые применяються непосредственно к grid-элементам⬇️

 align-self - свойство align-self задает выравнивание вдоль по вертикальной оси для отдельного элемента в гриде и по
 поперечной оси для отдельно взятого flex-блока. По сути данное свойство представляет собой свойство align-items, но для
 конкретного блока.
auto - элемент наследует значение от align-items контейнера сетки или, если не задано, stretch.
start,flex-start - выравнивает элемент к началу контейнера (вверх).
end,flex-end - выравнивает элемент к концу контейнера (вниз).
center - выравнивает элемент по центру контейнера.
stretch - растягивает элемент, чтобы заполнить ячейку по высоте (если это возможно).

justify-self - cвойство justify-self задает выравнивание отдельного элемента в гриде по горизонтальной оси. Свойство
применяется в том элементе, который мы хотим выравнять. это свойство будет игнарировать свойство для grid-контейнера justify-items

 grid-column-start,grid-row-start - свойство задает начальную позицию элемента в гриде или сетке по столбцам(рядам).
 grid-column-end,grid-row-end - свойство задает конечну позицию элемента в гриде или сетке по столбцам(рядам).
 Отрицательное значение(-1) говорит что это последная линия, значение(-2)-говорит что предпоследнее значение
 span- это называеться track, т.е. увеличение на число ячеек
 SHORTCUTS-КОРОТКАЯ ЗАПИСЬ
 grid-column: start/end
 grid-column: 1/4;
 grid-row: 1/-1;
 grid-row: 1/span 2;

grid-area - свойство задает имя элементу в гриде. Эти имена указываются в свойстве grid-template-areas, в котором
перечисляются имена элементов в том порядке, в котором их нужно разместить в гриде.
Пример 1:
grid-area: a;
grid-area: b;
grid-area: c;

Пример 2:
.wrapper {
    display: grid;
    grid-template-rows: 10vh 80vh 10vh;
    grid-template-columns: minmax(200px, 300px) auto;
    grid-template-areas:
    'h h'
    'a c'
    'f f';}

.header {
    grid-area: h;}
.aside {
    grid-area: a;}
.content {
    grid-area: c;}
.footer {
    grid-area: f;}
----------------------------------------------------------Переносы слов----------------------------------------------------------

Тег wbr указывает место, где браузер может сделать перенос строки в случае необходимости (если текст не помещается в
ширину элемента). Такие переносы называются мягкими.
При переносе слова через тег wbr символ переноса "-" не добавляется. Если он вам нужен - используйте символ мягкого
переноса &shy; (точка с запятой в конце обязательна, это не опечатка).

overflow-wrap - cвойство позволяет перенести буквы длинного слова на новую строку, если это слово не влазит в ширину контейнера.
word-wrap (устаревшее название)
Синтаксис
селектор {
	overflow-wrap: break-word | normal<-по-умалчанию;}

break-word-->Заставляет длинные слова переноситься на новую строку, если это слово не помещается в контейнер. Следующее
слово будет песаться не на той строке куда был сделан перенос, а на следующей(в этом отличие от word-break: break-all).
При этом слово начнется с новой строки. Такие переносы называются жесткими. Они не соответствуют правилам русского языка.
normal-->Стандартное поведение: если длинное слово не влазит по ширине в контейнер - оно просто вылезет за его границу (при этом начнется с новой строки).

word-break - свойство позволяет перенести буквы длинного слова на новую строку, если это слово не влазит в ширину контейнера.
 Синтаксис
 селектор {
	word-break: break-all | keep-all | normal<-по-умалчанию;
}
break-all-->Заставляет длинные слова переносится на новую строку, если это слово не помещается в контейнер. Следующее
слово будет песаться на той строке куда был сделан перенос(в этом отличие от overflow-wrap:break-word).
keep-all-->Для переноса иероглифов(китайские, японские иероглифы).
normal-->Стандартное поведение: если длинное слово не влазит по ширине в контейнер - оно просто вылезет за его границу (при этом начнется с новой строчки).

hyphens - свойство включает переносы слов в браузере с помощью знака переноса "-". Для поддержки русского языка
необходимо добавить атрибут lang="ru" к тегу, к которому применяются переносы (или к родителю этого тега). Можно просто
добавить этот атрибут к тегу html. Без этого переносы работать не будут.
Синтаксис
селектор {
	hyphens: auto | manual | none<-по-умалчанию;
}
auto-->Расставляет знаки переноса там, где это необходимо.
manual-->Добавляет переносы только в тех местах, где добавлен тег wbr или спецсимвол &shy; и только при необходимости.
none-->Отменяет расстановку переносов (слова не будут переносится, даже если есть мягкие переносы).

white-space - cвойство устанавливает как переносить текст на новую строку, а также как отображать пробелы
между словами и переносы строк (места, где был нажат Enter при наборе кода).
Синтаксис
селектор {
	white-space: nowrap | pre | pre-line | pre-wrap | normal<-по-умалчанию;
}

nowrap-->Запрещает тексту переносится на другую строку, даже если он не помещается в ширину контейнера (в этом случае
         текст просто вылезет за его границы). Однако, добавление тега br заставит текст перенестись на новую строку.
pre	--> Текст показывается так, как был набран в блокноте при верстке сайта: со всеми пробелами и enter-ами (если в
         коде набрано несколько пробелов - на экране тоже будет несколько). При этом браузер не будет переносить текст на новую
         строку, если он не помещается в контейнер - текст просто вылезет за его границы.
pre-wrap-->	То же самое, что и pre, отличие в том, что если текст слишком длинный и не влазит в контейнер - браузер
            перенесет его на другую строку.
pre-line-->	Браузер учитывает только Enter-ы в HTML коде и игнорирует все остальное (несколько пробелов будут выглядеть
            как один, браузер сам расставляет разрывы строк).
normal-->Стандартное поведение: браузер сам расставляет разрывы строки так, чтобы слова поместились в контейнер.
         Несколько пробелов в коде будут выглядеть как один на экране.

overflow-x - cвойство указывает браузеру, как поступать с содержимым, которое вылазит за границы блока по горизонтали.
overflow-y - cвойство указывает браузеру, как поступать с содержимым, которое вылазит за границы блока по вертикали.
overflow - cвойство указывает браузеру, как поступать с содержимым (текст, картинки, другие блоки), которое вылазит за
границы блока (за его ширину или высоту). Браузер может скрыть вылезающую часть, добавить полосы прокрутки или ничего
не делать (оставить как есть - вылезшим за границы).
Синтаксис
селектор {
	overflow: hidden | scroll | auto | visible<-по-умалчанию;
}

hidden-->Скрывает то содержимое, которое вылезло за границы блока.
scroll-->Добавляет полосы прокрутки, причем всегда, даже если ничего не вылазит (в этом случае они будут неактивными).
auto-->Добавляет полосы прокрутки при необходимости: если содержимое не помещается - они появятся, если все помещается -
их не будет.
visible-->Не скрывает то содержимое, которое вылезло за границы блока.

text-overflow - cвойство добавляет троеточие в конец обрезанного текста в знак того, что текст не помещался в блок и был обрезан.
Для работы свойства текст должен быть обрезан через свойство overflow или свойство overflow-x в значении hidden, auto
или scroll. Если задано visible (а так и есть по умолчанию) - text-overflow работать не будет.
Синтаксис
селектор {
    text-overflow: ellipsis | clip<-по-умалчанию;
}

ellipsis-->Добавляет в конец обрезанного текста троеточие.
clip-->Не добавляет троеточие в конец (это значение по умолчанию, нужно для отмены действия свойства при необходимости).

----------------------------------------------------------Не супер важное----------------------------------------------------------

title - атрибут тега(любого:div,p,...) задает всплывающую подсказку для элемента, которая будет появляться по наведению
мышкой на элемент (нужно навести и немного подержать курсор, секунду-две).
Пример:
css
.newDiv4 { width: 135px; background: grey; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; cursor: pointer; }
html
<div class="newDiv4" title="Приветствую Приветствую Приветствую Приветствую">
    Приветствую Приветствую Приветствую Приветствую
</div>


calc() - функция calc позволяет производить вычисления значений CSS свойств. Функция в качестве параметра принимает
математическое выражение, результат вычисления которого можно использовать как значение CSS свойства.
Выражение может включать операторы +, -, *, /.
Пример:
    width: calc(100vh - var(--header-width) - var(--footer-width));

z-index - cвойство устанавливает, кто будет сверху в случае, если несколько элементов накладываются друг на друга.
Любые позиционированные элементы на веб-странице могут накладываться друг на друга в определенном порядке, имитируя тем
самым третье измерение, перпендикулярное экрану. Каждый элемент может находиться как ниже, так и выше других объектов
веб-страницы, их размещением по z-оси и управляет z-index. Это свойство работает только для элементов, у которых значение
 position задано как absolute, fixed или relative.

 */

/* ================ */
/*Обнуление*/

*,
*:before,
*:after {
    padding: 0;
    margin: 0;
    border: 0;
    box-sizing: border-box;
}

html,
body {
    height: 100%;
    background-color: #b6b6b6;
    font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
    color: #fff;
    font-size: 20px;
    line-height: 24px;
    /*пример*/
    padding: 20px;
    font-weight: 500;
}

a {
    color: #794f45;
}

h1 {
    font-size: 20px;
    line-height: 1;
    margin: 0 0 50px 0;
}

h2 {
    font-size: 30px;
    line-height: 1;
    margin: 0 0 20px 0;
}

ul {
    list-style: none;
}

/* ================ */

/*Объяснение*/

/*Селектор по типу элемента*/
body {
    /*font-size: 46px;*/
    margin: 0;
    height: auto;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}

h3,
p,
div {
    color: #000;
}

div {
    width: 480px;
    background: tomato;
    /*overflow-wrap: normal;*/
    margin: 30px 0;
}

.div1, .div2 {
    width: 80px;
}

.newDiv {
    width: 80px;
    background: deeppink;
    overflow-wrap: break-word;
}

.newDiv1 {
    width: 80px;
    background: #3b00ff;
    word-break: break-all;

}

.newDiv2 {
    width: 80px;
    background: #8d8dde;
    hyphens: auto;
}

.newDiv3 {
    width: 125px;
    background: grey;
    white-space: nowrap;
}

.newDiv4 {
    width: 135px;
    background: grey;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    cursor: pointer;
}

.newDiv5 {
    height: 60px;
    width: 140px;
    background: grey;
    /*white-space: nowrap;*/
    /*overflow: auto;*/
    overflow-x: auto;
    overflow-y: auto;
    text-overflow: ellipsis;
    cursor: pointer;
}

.newDiv6 {
    height: 60px;
    width: 140px;
    background: grey;
    white-space: nowrap;
    /*overflow: auto;*/
    overflow-x: auto;
    overflow-y: auto;
    /*text-overflow:ellipsis;*/
    cursor: pointer;
}

.newDiv7 {
    --my-width: 480px;
    --header-width: 200px;
    --footer-width: 300px;
    background: tomato;
    height: 100px;
    width: 320px;
    width: calc(480px - 60px - 100px);
    width: calc(var(--my-width) - var(--header-width) - var(--footer-width));
    width: calc(100vh - var(--header-width) - var(--footer-width));
    /*480 - 60 -100=320*/
}
.boxIndex{
    position: relative;
}
.divIndex1,.divIndex2,.divIndex3{
    width: 150px;
    height: 150px;
    position: absolute;
}
.divIndex1{
    background: deeppink;
    z-index: 1;
}
.divIndex2{
    background: greenyellow;
    top:30px;
    left: 30px;
    z-index: 1;
}
.divIndex3{
    background: #ffff14;
    top:60px;
    left: 60px;
}



























