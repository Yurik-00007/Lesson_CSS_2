/*
Уроки по CSS для НАЧИНАЮЩИХ
https://www.youtube.com/playlist?list=PL6NCtzCz-4pQZ-uueXnuIcQMs085CAhty

Как строиться css
СЕЛЕКТОР{
СВОЙСТВО:ЗНАЧЕНИЕ;
СВОЙСТВО:ЗНАЧЕНИЕ;
СВОЙСТВО:ЗНАЧЕНИЕ;
}
------------------------------------------------Селекторы и Комбинаторы------------------------------------------------
Селекторы:
    1. По типу элемента: input, span,div
    2. По классу: .class__name
    3. По идентификатору:#id_name
    4. Универсальный:*
    5. По атрибуту:
        5.1. [атрибут="A"]: состоит из A
        5.2. [атрибут$="A"]: оканчивается на A
        5.3. [атрибут*="A"]: содержит A
        5.4. [атрибут^="A"]: начинается с A
        5.5. [атрибут|="A"]: содержит A в слове с дефисом(-)
        5.6. [атрибут~="A"]: содержит A в слове с пробелом
Комбинаторы:
    1. Запятая: А, В
    2. Пробел: А В
Комбинатор потомков (пробел) - этот комбинатор выбирает все элементы, которые являются потомками определенного элемента.
    3. Дочерние: А > В
Дочерний комбинатор (>) - этот комбинатор выбирает элементы, которые являются непосредственными дочерними элементами
определенного элемента.
    4. Все соседние элементы: А ~ В
Общий соседний комбинатор (~) - этот комбинатор выбирает все элементы, которые являются соседними элементами
(находятся на одном уровне вложенности) после определенного элемента.
 CSS символ ~ используется как комбинатор соседних элементов общего родителя. Он позволяет выбирать элементы, которые
 имеют общего родителя и находятся после указанного элемента, но не обязательно непосредственно после него.
    5. Следующий соседний элемент: А + В
Смежный комбинатор (+) - этот комбинатор выбирает(один) элемент, который является непосредственным соседом (следующим)
определенного элемента.
В CSS символ + используется как комбинатор смежных соседей. Он позволяет выбирать элемент, который следует сразу за
указанным элементом и находится на одном уровне в иерархии DOM (имеет общего родителя).

---------------------------------------------Псевдоклассы и Псевдоэлементы---------------------------------------------

Псевдокласс в CSS — это ключевое слово, добавленное к селектору, которое определяет его особое состояние.
	Псевдоклассы:
		1. :active-> Когда пользователь нажимает на элемент.
		2. :hover-> Когда указатель мыши находится над элементом.
		3. :focus->При навигации с помощью клавиатуры или клике на элемент.
		4. :first-child-> Этот псевдокласс применяется к первому дочернему элементу родителя.
		5. :last-child->Этот псевдокласс применяется к последнему дочернему элементу родителя
		6. :nth-child(n/odd/even)->Этот псевдокласс применяется к элементам на основе их позиции в группе братских элементов.
		7. :nth-of-type(n)->Этот псевдокласс работает аналогично :nth-child, но учитывает только элементы определенного типа.
		7. :required->то есть обязательные для заполнения,
		    :checked->Этот псевдокласс применяется к элементам типа чекбоксов или радиокнопок, которые выбраны (отмечены),
		    :disabled-> Этот псевдокласс применяется к элементам, которые отключены (неактивны).
		8. :not()->Этот псевдокласс выбирает элементы, которые не соответствуют указанному селектору.

Псевдоэлемент в CSS — это ключевое слово, добавляемое к селектору, которое позволяет стилизовать определённую часть
выбранного элемента. Псевдоэлементобязательно должен содержать content: '' и display: inline-block;

	Псевдоэлементы:
		1. ::before
		Псевдоэлемент before вставляет текст перед элементом. Используется только совместно со свойством content,
		которое задает текст, который следует вставить. И display: inline-block; который говорит что объект должен иметь
		область видимости
		2. ::after
		3. ::placeholder

--------------------------------------------- Позиционирование(position) ---------------------------------------------

	position: static/relative/absolute/fixed;
	top, left, right, bottom
	В CSS свойства position и top, left, right, bottom используются для управления расположением элементов на веб-странице.
	1. position: static - значение по умолчанию. Элементы с position: static расположены в нормальном потоке документа.
	Свойства top, left, right, bottom для них не применяются.
	2. position: relative - элемент с position: relative располагается относительно своего обычного положения. Свойства
	top, left, right, bottom смещают элемент относительно его нормального положения.
	3. position: absolute - элемент с position: absolute позиционируется относительно ближайшего предка с position: relative,
	position: absolute или position: fixed. Если такого предка нет, то относительно начального контекста (обычно это <html>).
	4. position: fixed - элемент с position: fixed позиционируется относительно окна браузера и остается на месте даже
	при прокрутке страницы.

--------------------------------------------- background ---------------------------------------------

    0.Запись в одну строку
    background: #eee url('./cat.ico') no-repeat center center/contain;*!
    #eee->Устанавливает цвет фона элемента
    url('./cat.ico')->Устанавливает фоновое изображение, находящееся по указанному пути
    no-repeat->Указывает, что фоновое изображение не должно повторяться.
    center center->Центрирует фоновое изображение по горизонтали и вертикали внутри элемента.
    contain->Масштабирует фоновое изображение так, чтобы оно полностью поместилось внутри элемента, сохраняя свои пропорции.

	1.background
	Универсальное свойство background позволяет установить одновременно несколько характеристик фона.

	2.background-attachment: fixed, scroll
	Свойство background-attachment устанавливает, будет ли прокручиваться фоновое изображение вместе с содержимым элемента.

	3.background-image,
	Устанавливает фоновое изображение для элемента.

	4.background-origin: https://webref.ru/css/background-origin
	Свойство background-origin определяет область позиционирования фонового рисунка.

	5.background-repeat: repeat-x, repeat-y, no-repeat, space,
	Определяет, как будет повторяться фоновое изображение.

	6.background-size: cover, contain, %, px
	Масштабирует фоновое изображение, согласно заданным размерам.
	cover - масштабирует изображение с сохранением пропорций так, чтобы его ширина или высота равнялась ширине или высоте блока.
	(будет растягивать картинку пока картинка не достигнет обе границы и будет сильно увеличивать изображение)
	contain - масштабирует изображение с сохранением пропорций таким образом, чтобы картинка целиком поместилась внутрь
	блока(будет растягивать картинку пока картинка не достигнет размера какой-то границы).

	7.background-position: center center
	Задаёт начальное положение фонового изображения. Порядок не имеет значения(сначало по x потом по y),
	можно писать top,bottom, left, right, center

	8.background:linear-gradient(to top, #fefcea, #f1da36)
	Стилевая функция linear-gradient() добавляет линейный градиент к фону элемента. Она выступает значением свойства
	background-image или background.

---------------------------------------- Приоритет !important :root переменные ----------------------------------------


		Специфичность селекторов, !important, :root + переменные

Приоритет от наибольшего к наименьшему:
a - число id
b - число классов, атрибутов, псевдо-классов
c - число псевдоэлементов, тегов

:not - не участвует, но селектор внутри участвует
*, комбинаторы - не участвуют

чем длиннее тем больше приоритет :)

*               a=0 b=0 c=0 -> специфичность = 000
li              a=0 b=0 c=1 -> специфичность = 001
ul li           a=0 b=0 c=2 -> специфичность = 002
ul ol+li        a=0 b=0 c=3 -> специфичность = 003
h1 + *[href="www."]  a=0 b=1 c=1 -> специфичность = 011
ul ol li.red    a=0 b=1 c=3 -> специфичность = 013
li.red.level    a=0 b=2 c=1 -> специфичность = 021
#test           a=1 b=0 c=0 -> специфичность = 100
#test:not(p)    a=1 b=0 c=1 -> специфичность = 101
#test:not(p.test)    a=1 b=1 c=1 -> специфичность = 111


	!important — это специальная директива, используемая в CSS для повышения приоритета стиля, при которой стиль,
	помеченный !important, будет применяться, даже если существуют другие, более специфичные селекторы или стили, заданные позже в коде.

Переменные в css можно расположить в псевдоклассе: root{} и тогда переменные будут глобальные, а если их расположить в
каком-то классе то они будут локальные.
:root — это селектор, который соответствует корневому элементу документа. В HTML он эквивалентен селектору html.
    Переменные в css:
    СЕЛЕКТОР {
        --ИМЯ:ЗНАЧЕНИЕ;
        }
          СЕЛЕКТОР {
        СВОЙСТВО:var(--ИМЯ);
        }

---------------------------------------- Адаптивная верстка viewport ----------------------------------------

Чтобы строчка отображалась нормально на любых устройствах можно вставить такой костыль, который просто копируешь
вставлять из проекта в проект
    <meta name="viewport" content="width=device-width, initial-scale=1">

viewport
	Логический оператор: and or(,) not
	Тип носителя: all-для всех, screen-для различных мониторов, print-для печати, speech-для голосовых ассистентов
	Характеристики: width, height, aspect-ratio-соотношение сторон, orientation(portrait-вертик., landscape-горизонт.)-ориентация

	@media УСЛОВИЕ {
    .container{
        background: aqua;
    }}

	Пример:
	или
	@media print {
    или
	@media (max-width: 900px)
	или
	@media (aspect-ratio: 4/3)

	{.container{
        font-size: 6px;
        background: aqua;}
}

------------------------------------transition------------------------------------

В классе указывается transition а в псевдоклассе(:hover) или медиа-запросе укрываются свойства которые нужно изменить

.container {
    width: 500px;
    height: 500px;
    background: tomato;
    transition: font-size 1.5s linear .5s;
}
transition:  font-size           1.5s            linear           .5s;
            свойства=all    длительность=0s   скорость=ease   анимации=0s
              property          duration      timing-function      delay


transition можно использовать с псевдоклассами и с медиа-запросами

 Универсальное свойство, которое позволяет одновременно задать значения transition-property, transition-duration,
 transition-timing-function и transition-delay.

 Устанавливает эффект перехода между двумя состояниями элемента, они могут быть определены с помощью псевдокласса
:hover или :active, а также динамически через JavaScript.

1.Свойство transition-delay устанавливает время ожидания перед запуском эффекта перехода.

2.Свойство transition-property устанавливает имя стилевого свойства, значение которого будет отслеживаться для
создания эффекта перехода.

3.Свойство transition-duration задаёт время в секундах или миллисекундах, сколько должна длиться анимация перехода
до её завершения.

4.Свойство transition-timing-function устанавливает, насколько быстро должно изменяться значение стилевого свойство
для которого применяется эффект перехода.

.container:hover {
    background: green;
    font-size: 26px;
    color: white;
}

/*@media (max-width: 800px) {
    .container {
        background: yellow;
    }
}

------------------------------------animation------------------------------------

CSS-анимации позволяют анимировать переходы от одной конфигурации CSS стилей к другой.
animation - универсальное свойство, которое задаёт сразу несколько параметров анимации.

    animation-name: changeMargin; !*имя->может быть любое*!
    animation-duration: 5s; !*длительность->может быть любая *!
    animation-timing-function: ease; !*скорость-> ease | ease-in | ease-out | ease-in-out | linear*!
    animation-delay: 1.5s; !*задержка->может быть любая *!
    animation-fill-mode: forwards;
    !*какие стили должны применяться к элементу, когда анимация закончиться->none | forwards | backwards | both*!
    animation-iteration-count: infinite; !*кол-во повторений->может быть любое(infinite-бесконечность) *!
    animation-direction: alternate; !*направление движения анимации->normal | alternate | reverse | alternate-reverse*!

Короткая запись:
    animation:5s ease 1.5s forwards infinite alternate changeMargin

Порядок:
 animation:1s ease .5s infinite alternate move

animation: duration|timing-function|
delay|iteration-count|
direction|fill-mode|name

Правило @keyframes устанавливает ключевые кадры при анимации элемента. Ключевой кадр это свойства элемента (прозрачность,
цвет, положение и др.), которые должны применяться к элементу в заданный момент времени. Таким образом, анимация
представляет собой плавный переход стилевых свойств от одного ключевого кадра к другому. Вычисление промежуточных
значений между такими кадрами берёт на себя браузер.
Анимация может использовать ключевые слова from и to, а так же проценты 0% 20% 50% 100%

@keyframes move {
    from{
    margin-top:0;
    }
    to{
        margin-left: 500px;
    }
}

------------------------------------transform------------------------------------

Трансформирует элемент, в частности, позволяет его масштабировать, вращать, сдвигать, наклонять, а также комбинировать
виды трансформаций, перечисляя функции трансформации через пробел.

transform-origin-Устанавливает координаты точки, относительно которой будет происходить трансформация элемента.


Функции трансформации:

rotate()-Поворачивает элемент в двумерном пространстве на заданный угол относительно точки трансформации, задаваемой
свойством transform-origin.

scale()-Масштабирует элемент по горизонтали и вертикали.

translate()-Сдвигает элемент на заданное значение по горизонтали и вертикали.

translateX()-Сдвигает элемент по горизонтали на указанное значение. Положительное значение сдвигает вправо, отрицательное влево.

translateY()-Сдвигает элемент по вертикали на указанное значение. Положительное значение сдвигает вниз, отрицательное вверх.

translateZ()-Сдвигает элемент по оси Z на указанное значение. Положительное значение сдвигает вперёд, отрицательное назад.

Первоначально нужно задать начальные значения для transform и transform-origin(если нужно вращать) в классе и задать
animation с именем и параметрами, а потом задать @keyframes с именем и конечными значениями transform

Пример
.circle {
    transform: rotate(0deg);
    transform-origin: top left;
    animation:5s ease .5s forwards infinite alternate translateX;
}

@keyframes translateX {
    50% {
        transform: rotate(360deg) translate(100px) scale(2);
    }
    100%{
        transform: rotate(720deg) translate(0px) scale(1);
    }
}

------------------------------------box-sizing------------------------------------

box-sizing - Применяется для изменения алгоритма расчёта ширины и высоты элемента.

Согласно спецификации CSS ширина блока складывается из ширины содержимого (width), значений margin, padding и border.
Свойство box-sizing позволяет изменить этот алгоритм, чтобы свойства width и height задавали размеры не содержимого, а
размеры блока.

content-box
Основывается на стандартах CSS, при этом свойства width и height задают ширину и высоту содержимого и не включают в себя
значения margin, padding и border.

border-box
Свойства width и height включают в себя значения padding и border, но не margin.
Синтаксис
box-sizing: content-box | border-box
Рекомендую делать такую запись в начале каждого css документа
*{
    box-sizing: border-box;
}

------------------------------------Префиксы------------------------------------

Префиксы нужны для кроссбраузерности, то есть чтобы отображалась нормально на разных браузерах.
Префиксы обычно в ручную не пишутся.
Кросбраузерность это когда сайт выглядит одинаково в разных браузерах

autoprefixer: http://autoprefixer.github.io/ru/

------------------------------------normalize------------------------------------

normalize исходники: https://clck.ru/VRmgD
Этот файл будет как осново для начало работы, чтобы все браузеры отображали сайт одинаково и сбрасывает не нужные стили


------------------------------------normalize & reset------------------------------------
Ссылки на сайт которые сбрасывают настройки до normalize или reset

normalize.css: https://cdnjs.com/libraries/normalize
reset.css: https://cdnjs.com/libraries/meyer-reset

Они подключаются через html-> link
    <link
            rel="stylesheet"
            type="text/css"
            href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css"
    />


------------------------------------Не супер важные свойства------------------------------------
1.line-height - свойство line-height устанавливает интервал между строками текста (межстрочный интервал).
2.list-style-type - свойство list-style-type позволяет для списка ul вместо маркеров-точек сделать квадраты или окружности.
Для списка ol вместо обычных цифр можно сделать римские, нумерацию в виде букв: латинских или греческих. Часто используется
с none чтобы убрать значения по умолчанию для списка.
3.text-decoration - cвойство text-decoration добавляет тексту различные эффекты: подчеркивание, перечеркивание, линию сверху.
Часто используется чтобы отменить подчеркивания ссылки.
4.box-shadow - Свойство box-shadow задает тень блоку. В качестве значения свойство принимает 6 параметров, перечисляемые
через пробел, либо ключевое слово none, отменяющее тень совсем.
https://active-vision.ru/icon/box-shadow/
5.object-fit - управляет соотношением сторон заменяемых элементов, таких как <img> и <video>, когда у них задана ширина
или высота, а также способом масштабирования. свойство похоже на background-size
object-fit: fill | contain | cover | none
    fill - элемент масштабируется, чтобы соответствовать заданным размерам, при этом пропорции игнорируются.
	cover - масштабирует изображение с сохранением пропорций так, чтобы его ширина или высота равнялась ширине или высоте блока.
	(будет растягивать картинку пока картинка не достигнет обе границы и будет сильно увеличивать изображение)
	contain - масштабирует изображение с сохранением пропорций таким образом, чтобы картинка целиком поместилась внутрь
	блока(будет растягивать картинку пока картинка не достигнет размера какой-то границы).
	none - сохраняются исходные пропорции элемента, установленные значения ширины или высоты не влияют на содержимое.
6. object-position - cвойство object-position применяется для выравнивания содержимого такого элемента как <img>, <video> или <object>
внутри его блока. Это свойство работает аналогично background-position для фоновых изображений.
7.inherit - ключевое слово, которое сообщает, что необходимо наследовать значение свойства у родительского элемента. Естественно,
результат будет заметен только в том случае, если у родителя указанное свойство установлено.
8.min-width - устанавливает максимальную ширину элемента.
9.max-width - устанавливает минимальную ширину элемента.
10. filter - Свойство filter задает фоновому изображению определенный художественный стиль или фильтр. Свойство может
принимать в качестве значений названия художественных стилей, формируемых функцией filter или none (отмена выбранного
фильтра).
filter:blur()->размытие, brightness()->яркость, contrast()->контрастность, grayscale()->чернобелость, saturate()->насыщенность,
sepia()->старина, invert()->инвертация, opacity()->прозрачности.

----------------------------------------------------------grid----------------------------------------------------------
display: grid
Grid представляет собой пересекающийся набор горизонтальных и вертикальных линий, образующих колонки и строки.
Элементы могут быть помещены в grid в пределах линий этих колонок и строк.

display: grid — это CSS-свойство, которое преобразует элемент в контейнер сетки (grid container).
Внутри этого контейнера его дочерние элементы (grid items) располагаются в виде сетки, что позволяет легко управлять
их расположением и размером.

grid-template-columns - свойство grid-template-columns задает количество и ширину столбцов, которые будет занимать
элемент в гриде или сетке.
Единицы измерения:
 -> пикселях размеры столбцов будут точно им соответствовать.
 ->auto, то столбцы будут заполнять все доступное пространство.
 ->fr (фракция) означает, что все пространство будет разбито на одинаковые доли(преимущество адаптивность).
 пример:
  grid-template-columns: 200px 200px 200px;
  или короткая запись
   grid-template-columns: repeat(3, 200px);->кол-во колонок, размер

 grid-template-rows - свойство grid-template-rows задает количество и ширину рядов, которые будет занимать элемент в
 гриде или сетке.

grid-auto-rows,grid-auto-columns - свойство grid-auto-columns,rows задает количество и ширину столбцов(строк), которые
будет занимать элемент в неявном гриде.Т.е. можно задать размер для одной строки( grid-template-rows: 200px), а потом с
 помощью grid-auto-rows задать свойство, которое будет применяться для остальных строк().


 minmax() это CSS функция, определяющая диапазон размеров, который больше или равен min и меньше или равен max.
 Аналогично min-width и max-width, но только для grit-self.
 пример:
 grid-template-columns: repeat(3,minmax(100px,200px));

 gap - свойство gap задает расстояние между элементами в гриде. В значении свойства в элементе-родителе указываем нужное
 нам расстояние с единицами измерения - px, % и т.п.
 или есть альтернативные свойства grid-column-gap и grid-row-gap

 justify-items - свойство justify-items задает выравнивание элементов внутри ячеек grid по горизонтальной оси.Применяется
 к родительскому элементу.
 align-items - свойство align-items задает выравнивание элементов вдоль по вертикальной оси для grid и поперечной оси
 для flex блоков. Применяется к родительскому элементу.

 align-self - свойство align-self задает выравнивание вдоль по вертикальной оси для отдельного элемента в гриде и по
 поперечной оси для отдельно взятого flex-блока. По сути данное свойство представляет собой свойство align-items, но для
 конкретного блока.
auto - элемент наследует значение от align-items контейнера сетки или, если не задано, stretch.
start,flex-start - выравнивает элемент к началу контейнера (вверх).
end,flex-end - выравнивает элемент к концу контейнера (вниз).
center - выравнивает элемент по центру контейнера.
stretch - растягивает элемент, чтобы заполнить ячейку по высоте (если это возможно).

justify-self - cвойство justify-self задает выравнивание отдельного элемента в гриде по горизонтальной оси. Свойство
применяется в том элементе, который мы хотим выравнять.

auto - столбцы с auto подстраиваются под контент, занимая минимально необходимое пространство.
пример: grid-template-columns: 1fr auto auto;
1fr - выберут самую большую ячейку и от размера её сделают для каждой ячейки такой размер.

свойства можно объединять вот некоторые, которые часто применяються из них:
grid-template: стрки/столбцы
grid-template: 300px 300px 300px/ 1fr 1fr 1fr;
grid-template:repeat(3, 300px)/ repeat(3, 1fr);

 */




*{
    box-sizing: border-box;
}
/*Селектор по типу элемента*/
body {
    /*font-size: 46px;*/
    margin: 0;
    height: 150vh;
    display: flex;
    justify-content: center;
    align-items: center;
}

.wrapper{
    background: tomato;
    /*width: 500px;*/
}
/*
.container{
    background:lightgray;
    display: grid;
    grid-template-columns: 200px 200px 200px;
    grid-template-rows: 200px;
}
*/
.container{
    /*background:lightgray;*/
    display: grid;
    /*grid-template-columns: repeat(3, 200px);*/
    /*grid-template-columns: repeat(3, 1fr);*/
    /*grid-template-columns: 1fr 1fr 1fr;*/
    /*grid-template-columns: repeat(3,minmax(100px,200px));*/
    /*grid-template-rows: 200px;*/
    /*grid-auto-rows: 300px;*/
    /*
    grid-column-gap: 30px;
    grid-row-gap: 30px;
    */
    /*grid-template-columns: repeat(3, 1fr);*/
    /*grid-template-columns: 1fr auto auto;*/
    /*grid-template-columns: 1fr 1fr 1fr;*/
    /*grid-template:300px 300px 300px/ 1fr 1fr 1fr;*/
    grid-template:repeat(3, 300px)/ repeat(3, 1fr);

/*
    grid-template-columns: repeat(3, 300px);
    grid-template-rows: repeat(3, 300px);
justify-items: center;
    align-items: center;
*/
}

.child{
    display: flex;
    justify-content: center;
    align-items: center;
    color: white;
    font-size: 50px;
    width: 150px;
    height: 150px;
    border-radius: 5px;
    border: 1px solid black;
}



.child1{
    background: #f60;
    width: 200px;
}
.child2{
    background: #c03;
    width:300px
    /*align-self: flex-end;*/
}
.child3{
    background: #906;
    /*justify-self:start*/
    min-width: 150px;
}
.child4{
    background: #60f;
}
.child5{
    background: #066;
}
.child6{
    background: #393;
}
.child7{
    background: #fc0;
}
.child8{
    background: #3cf;
}
.child9{
    background: #3c9;
}










































